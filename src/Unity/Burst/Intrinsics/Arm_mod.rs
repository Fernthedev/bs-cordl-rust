#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
#[repr(C)]
#[derive(Debug)]
pub struct Arm {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
unsafe impl quest_hook::libil2cpp::Type for crate::Unity::Burst::Intrinsics::Arm {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "Unity.Burst.Intrinsics";
    const CLASS_NAME: &'static str = "Arm";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl std::ops::Deref for crate::Unity::Burst::Intrinsics::Arm {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &Self::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl std::ops::DerefMut for crate::Unity::Burst::Intrinsics::Arm {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl crate::Unity::Burst::Intrinsics::Arm {
    #[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
    pub type Neon = crate::Unity::Burst::Intrinsics::Arm_Neon;
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm")]
impl quest_hook::libil2cpp::ObjectType for crate::Unity::Burst::Intrinsics::Arm {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
#[repr(C)]
#[derive(Debug)]
pub struct Arm_Neon {
    __cordl_parent: quest_hook::libil2cpp::Il2CppObject,
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
unsafe impl quest_hook::libil2cpp::Type for crate::Unity::Burst::Intrinsics::Arm_Neon {
    type Held<'a> = ::std::option::Option<&'a mut Self>;
    type HeldRaw = *mut Self;
    const NAMESPACE: &'static str = "Unity.Burst.Intrinsics";
    const CLASS_NAME: &'static str = "Arm/Neon";
    fn matches_reference_argument(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        ty.class().is_assignable_from(<Self as quest_hook::libil2cpp::Type>::class())
    }
    fn matches_value_argument(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
    fn matches_reference_parameter(ty: &quest_hook::libil2cpp::Il2CppType) -> bool {
        <Self as quest_hook::libil2cpp::Type>::class().is_assignable_from(ty.class())
    }
    fn matches_value_parameter(_: &quest_hook::libil2cpp::Il2CppType) -> bool {
        false
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl std::ops::Deref for crate::Unity::Burst::Intrinsics::Arm_Neon {
    type Target = quest_hook::libil2cpp::Il2CppObject;
    fn deref(&self) -> &Self::Target {
        unsafe { &self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl std::ops::DerefMut for crate::Unity::Burst::Intrinsics::Arm_Neon {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe { &mut self.__cordl_parent }
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl crate::Unity::Burst::Intrinsics::Arm_Neon {
    pub fn New() -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Gc<Self>> {
        let __cordl_object: &mut Self = <Self as quest_hook::libil2cpp::Type>::class()
            .instantiate();
        quest_hook::libil2cpp::ObjectType::as_object_mut(__cordl_object)
            .invoke_void(".ctor", ())?;
        Ok(__cordl_object.into())
    }
    pub fn __crc32b(a0: u32, a1: u8) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u8), u32, 2usize>("__crc32b")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32b", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cb(a0: u32, a1: u8) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u8), u32, 2usize>("__crc32cb")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32cb", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cd(a0: u32, a1: u64) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u64), u32, 2usize>("__crc32cd")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32cd", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32ch(a0: u32, a1: u16) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u16), u32, 2usize>("__crc32ch")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32ch", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32cw(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u32), u32, 2usize>("__crc32cw")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32cw", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32d(a0: u32, a1: u64) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u64), u32, 2usize>("__crc32d")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32d", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32h(a0: u32, a1: u16) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u16), u32, 2usize>("__crc32h")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32h", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn __crc32w(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u32), u32, 2usize>("__crc32w")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "__crc32w", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn _ctor(
        &mut self,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_method::<(), quest_hook::libil2cpp::Void, 0usize>(".ctor")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, ".ctor", 0usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked(self, ())
        };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonArmv82FeaturesSupported() -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(), bool, 0usize>("get_IsNeonArmv82FeaturesSupported")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "get_IsNeonArmv82FeaturesSupported", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked((), ()) };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonCryptoSupported() -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(), bool, 0usize>("get_IsNeonCryptoSupported")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "get_IsNeonCryptoSupported", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked((), ()) };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonDotProdSupported() -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(), bool, 0usize>("get_IsNeonDotProdSupported")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "get_IsNeonDotProdSupported", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked((), ()) };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonRDMASupported() -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(), bool, 0usize>("get_IsNeonRDMASupported")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "get_IsNeonRDMASupported", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked((), ()) };
        Ok(__cordl_ret.into())
    }
    pub fn get_IsNeonSupported() -> quest_hook::libil2cpp::Result<bool> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(), bool, 0usize>("get_IsNeonSupported")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "get_IsNeonSupported", 0usize
                )
            });
        let __cordl_ret: bool = unsafe { method.invoke_unchecked((), ()) };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vaba_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaba_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vaba_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaba_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vaba_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaba_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vaba_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaba_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vaba_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaba_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaba_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vaba_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaba_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_high_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_high_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_high_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_high_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabal_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabal_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabal_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabaq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabaq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabaq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabaq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabaq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabaq_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabaq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabaq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabaq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabaq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabaq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vabaq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabaq_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vabd_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabd_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), f64, 2usize>("vabdd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdd_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_high_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_high_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdl_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabdq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vabdq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabdq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabds_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), f32, 2usize>("vabds_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabds_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vabs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabs_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vabs_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabs_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vabs_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabs_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vabs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabs_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vabs_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabs_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabs_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vabs_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabs_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), i64, 1usize>("vabsd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabsd_s64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vabsq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabsq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vabsq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabsq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vabsq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabsq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vabsq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabsq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vabsq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabsq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vabsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vabsq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vabsq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vadd_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vadd_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vaddd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddd_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vaddd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vaddhn_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vaddhn_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vaddhn_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_high_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vaddhn_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_high_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vaddhn_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_high_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vaddhn_high_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_high_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vaddhn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vaddhn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vaddhn_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vaddhn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vaddhn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vaddhn_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddhn_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_high_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_high_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddl_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i32,
                1usize,
            >("vaddlv_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlv_s16", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i64,
                1usize,
            >("vaddlv_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlv_s32", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i16,
                1usize,
            >("vaddlv_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlv_s8", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u32,
                1usize,
            >("vaddlv_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlv_u16", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u64,
                1usize,
            >("vaddlv_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlv_u32", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u16,
                1usize,
            >("vaddlv_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlv_u8", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i32,
                1usize,
            >("vaddlvq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlvq_s16", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i64,
                1usize,
            >("vaddlvq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlvq_s32", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i16,
                1usize,
            >("vaddlvq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlvq_s8", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u32,
                1usize,
            >("vaddlvq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlvq_u16", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u64,
                1usize,
            >("vaddlvq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlvq_u32", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddlvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u16,
                1usize,
            >("vaddlvq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddlvq_u8", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vaddv_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddv_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i16,
                1usize,
            >("vaddv_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddv_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i32,
                1usize,
            >("vaddv_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddv_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i8,
                1usize,
            >("vaddv_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddv_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u16,
                1usize,
            >("vaddv_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddv_u16", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u32,
                1usize,
            >("vaddv_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddv_u32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u8,
                1usize,
            >("vaddv_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddv_u8", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f32,
                1usize,
            >("vaddvq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vaddvq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i16,
                1usize,
            >("vaddvq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i32,
                1usize,
            >("vaddvq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i64,
                1usize,
            >("vaddvq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_s64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i8,
                1usize,
            >("vaddvq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u16,
                1usize,
            >("vaddvq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_u16", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u32,
                1usize,
            >("vaddvq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_u32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u64,
                1usize,
            >("vaddvq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_u64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u8,
                1usize,
            >("vaddvq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddvq_u8", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_high_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_high_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaddw_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaddw_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaddw_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaesdq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaesdq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaesdq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaeseq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vaeseq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaeseq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaesimcq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vaesimcq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaesimcq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vaesmcq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vaesmcq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vaesmcq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vand_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vand_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vand_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vandq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vandq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vandq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbic_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vbic_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbic_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbicq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vbicq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbicq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbsl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vbsl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbsl_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vbslq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vbslq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vbslq_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcage_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcage_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcage_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcage_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcage_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcage_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaged_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcaged_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcaged_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcageq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcageq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcageq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcageq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcageq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcageq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcages_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vcages_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcages_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcagt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcagt_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcagt_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcagt_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcagt_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcagtd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcagtd_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcagtq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcagtq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcagtq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcagtq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcagts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vcagts_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcagts_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcale_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcale_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcale_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcale_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcale_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcale_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaled_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcaled_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcaled_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcaleq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcaleq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcaleq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaleq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcaleq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcaleq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcales_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vcales_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcales_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcalt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcalt_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcalt_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcalt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcalt_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcalt_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcaltd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcaltd_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcaltq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcaltq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcaltq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcaltq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcaltq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcalts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vcalts_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcalts_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceq_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vceq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vceqd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqd_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), u64, 2usize>("vceqd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqd_s64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceqd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vceqd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vceqq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqs_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vceqs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqs_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqz_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vceqz_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqz_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vceqzd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzd_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), u64, 1usize>("vceqzd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzd_s64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzd_u64(a0: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64), u64, 1usize>("vceqzd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzd_u64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vceqzq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vceqzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vceqzs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vceqzs_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcge_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcge_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcge_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcged_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcged_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), u64, 2usize>("vcged_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcged_s64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcged_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vcged_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcged_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgeq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgeq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgeq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcges_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vcges_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcges_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgez_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgez_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgez_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgez_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgez_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgez_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgez_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgez_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgez_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgez_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgez_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgez_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgez_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcgezd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezd_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), u64, 1usize>("vcgezd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezd_s64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgezq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgezq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgezq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgezq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgezq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgezq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgezs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcgezs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgezs_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcgt_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgt_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcgtd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtd_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), u64, 2usize>("vcgtd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtd_s64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vcgtd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcgtq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vcgts_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgts_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgtz_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtz_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgtz_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtz_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgtz_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtz_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgtz_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtz_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgtz_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtz_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcgtz_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtz_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcgtzd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzd_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), u64, 1usize>("vcgtzd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzd_s64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgtzq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgtzq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgtzq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgtzq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgtzq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcgtzq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcgtzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcgtzs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcgtzs_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcle_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcle_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcle_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcled_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcled_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), u64, 2usize>("vcled_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcled_s64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcled_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vcled_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcled_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcleq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcleq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcleq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcles_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vcles_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcles_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclez_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclez_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclez_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclez_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclez_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclez_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclez_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclez_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclez_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclez_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclez_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclez_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclez_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vclezd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezd_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vclezd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), u64, 1usize>("vclezd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezd_s64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclezq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclezq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclezq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclezq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclezq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclezq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclezs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vclezs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclezs_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcls_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcls_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcls_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcls_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcls_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcls_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcls_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclsq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclsq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclsq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclsq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclsq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclsq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vclt_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclt_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), u64, 2usize>("vcltd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltd_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), u64, 2usize>("vcltd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltd_s64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcltd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vcltd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcltq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclts_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), u32, 2usize>("vclts_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclts_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcltz_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltz_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcltz_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltz_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcltz_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltz_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcltz_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltz_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcltz_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltz_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcltz_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltz_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzd_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcltzd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzd_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzd_s64(a0: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), u64, 1usize>("vcltzd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzd_s64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcltzq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcltzq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcltzq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcltzq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcltzq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcltzq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcltzs_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcltzs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcltzs_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclz_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclz_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclz_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclz_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclz_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclz_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclz_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclz_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclz_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclz_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclz_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vclz_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclz_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclzq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclzq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclzq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclzq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclzq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclzq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclzq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclzq_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclzq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclzq_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vclzq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vclzq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vclzq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcnt_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcnt_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcnt_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcnt_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcnt_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcnt_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcntq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcntq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcntq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcntq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcntq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcntq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_f16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_f16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcombine_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcombine_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcombine_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_s64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_s8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_u64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_lane_u8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_s64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_s8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_u64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopy_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vcopy_laneq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopy_laneq_u8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_s64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_s8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_u64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_lane_u8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_s64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_s8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_u64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcopyq_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vcopyq_laneq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcopyq_laneq_u8", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_f16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_f16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_f64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_s8(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u16(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u32(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcreate_u8(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcreate_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcreate_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_f32_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_f32_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_f32_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_f32_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_f32_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_f32_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvt_f64_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_f64_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_f64_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_f64_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_f64_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_f64_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_high_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvt_high_f32_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_high_f32_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_high_f64_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvt_high_f64_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_high_f64_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_f32_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_f32_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_f32_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_f32_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_f64_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_f64_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_f64_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_f64_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_s32_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_s64_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_u32_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_n_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vcvt_n_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_n_u64_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvt_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvt_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvt_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvta_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvta_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvta_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvta_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvta_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvta_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvta_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvta_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvta_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtad_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), i64, 1usize>("vcvtad_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtad_s64_f64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtad_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcvtad_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtad_u64_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtaq_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtaq_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtaq_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtaq_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtaq_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtaq_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtaq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtaq_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtaq_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtas_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), i32, 1usize>("vcvtas_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtas_s32_f32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtas_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcvtas_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtas_u32_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_f64_s64(a0: i64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), f64, 1usize>("vcvtd_f64_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_f64_s64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_f64_u64(a0: u64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64), f64, 1usize>("vcvtd_f64_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_f64_u64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_f64_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), f64, 2usize>("vcvtd_n_f64_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_n_f64_s64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_f64_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i32), f64, 2usize>("vcvtd_n_f64_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_n_f64_u64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_s64_f64(a0: f64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, i32), i64, 2usize>("vcvtd_n_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_n_s64_f64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_n_u64_f64(a0: f64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, i32), u64, 2usize>("vcvtd_n_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_n_u64_f64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), i64, 1usize>("vcvtd_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_s64_f64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcvtd_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtd_u64_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtm_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtm_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtm_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtm_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtm_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtm_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtm_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtm_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtm_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), i64, 1usize>("vcvtmd_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtmd_s64_f64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcvtmd_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtmd_u64_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtmq_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtmq_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtmq_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtmq_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtmq_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtmq_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtmq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtmq_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtmq_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtms_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), i32, 1usize>("vcvtms_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtms_s32_f32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtms_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcvtms_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtms_u32_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtn_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtn_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtn_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtn_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtn_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtn_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtn_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtn_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtn_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), i64, 1usize>("vcvtnd_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtnd_s64_f64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcvtnd_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtnd_u64_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtnq_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtnq_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtnq_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtnq_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtnq_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtnq_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtnq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtnq_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtnq_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtns_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), i32, 1usize>("vcvtns_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtns_s32_f32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtns_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcvtns_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtns_u32_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtp_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtp_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtp_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtp_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtp_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtp_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtp_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtp_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtp_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpd_s64_f64(a0: f64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), i64, 1usize>("vcvtpd_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtpd_s64_f64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpd_u64_f64(a0: f64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), u64, 1usize>("vcvtpd_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtpd_u64_f64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtpq_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtpq_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtpq_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtpq_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtpq_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtpq_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtpq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtpq_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtpq_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtps_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), i32, 1usize>("vcvtps_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtps_s32_f32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtps_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcvtps_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtps_u32_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_f32_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_f32_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_f32_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_f32_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_f64_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_f64_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_f64_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_f64_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f32_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_f32_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_f32_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f32_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_f32_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_f32_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f64_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_f64_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_f64_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_f64_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_f64_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_f64_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_s32_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_s64_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_u32_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_n_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtq_n_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_n_u64_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_s32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_s32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_s64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_s64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_s64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_u32_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_u32_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtq_u64_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vcvtq_u64_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtq_u64_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_f32_s32(a0: i32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32), f32, 1usize>("vcvts_f32_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_f32_s32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_f32_u32(a0: u32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32), f32, 1usize>("vcvts_f32_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_f32_u32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_f32_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), f32, 2usize>("vcvts_n_f32_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_n_f32_s32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_f32_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, i32), f32, 2usize>("vcvts_n_f32_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_n_f32_u32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_s32_f32(a0: f32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, i32), i32, 2usize>("vcvts_n_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_n_s32_f32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_n_u32_f32(a0: f32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, i32), u32, 2usize>("vcvts_n_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_n_u32_f32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_s32_f32(a0: f32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), i32, 1usize>("vcvts_s32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_s32_f32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvts_u32_f32(a0: f32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), u32, 1usize>("vcvts_u32_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvts_u32_f32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtx_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vcvtx_f32_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtx_f32_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtx_high_f32_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vcvtx_high_f32_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtx_high_f32_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vcvtxd_f32_f64(a0: f64) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), f32, 1usize>("vcvtxd_f32_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vcvtxd_f32_f64", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdiv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdiv_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdiv_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdiv_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdiv_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdiv_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdivq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdivq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdivq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdivq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdivq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdivq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vdot_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdot_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vdot_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdot_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vdot_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdot_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vdot_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdot_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vdot_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdot_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdot_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vdot_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdot_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vdotq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdotq_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vdotq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdotq_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vdotq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdotq_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vdotq_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdotq_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vdotq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdotq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdotq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vdotq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdotq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_lane_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vdup_laneq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_laneq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i8),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u16),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u32),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdup_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u8),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vdup_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdup_n_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i8,
                2usize,
            >("vdupb_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupb_lane_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u8,
                2usize,
            >("vdupb_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupb_lane_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i8,
                2usize,
            >("vdupb_laneq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupb_laneq_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupb_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u8,
                2usize,
            >("vdupb_laneq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupb_laneq_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                f64,
                2usize,
            >("vdupd_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupd_lane_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i64,
                2usize,
            >("vdupd_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupd_lane_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u64,
                2usize,
            >("vdupd_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupd_lane_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                f64,
                2usize,
            >("vdupd_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupd_laneq_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i64,
                2usize,
            >("vdupd_laneq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupd_laneq_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupd_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u64,
                2usize,
            >("vdupd_laneq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupd_laneq_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i16,
                2usize,
            >("vduph_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vduph_lane_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u16,
                2usize,
            >("vduph_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vduph_lane_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i16,
                2usize,
            >("vduph_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vduph_laneq_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vduph_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u16,
                2usize,
            >("vduph_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vduph_laneq_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_lane_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_laneq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vdupq_laneq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_laneq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i8),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u16),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u32),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdupq_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u8),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vdupq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdupq_n_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                f32,
                2usize,
            >("vdups_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdups_lane_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                2usize,
            >("vdups_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdups_lane_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u32,
                2usize,
            >("vdups_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdups_lane_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                f32,
                2usize,
            >("vdups_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdups_laneq_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i32,
                2usize,
            >("vdups_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdups_laneq_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vdups_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u32,
                2usize,
            >("vdups_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vdups_laneq_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veor_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("veor_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veor_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn veorq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("veorq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "veorq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vext_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vext_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vext_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vextq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vextq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vextq_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfma_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfma_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfma_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfma_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_lane_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfma_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfma_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_laneq_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfma_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfma_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    f64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfma_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfma_n_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmad_lane_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, f64, crate::Unity::Burst::Intrinsics::v64, i32),
                f64,
                4usize,
            >("vfmad_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmad_lane_f64", 4usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vfmad_laneq_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, f64, crate::Unity::Burst::Intrinsics::v128, i32),
                f64,
                4usize,
            >("vfmad_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmad_laneq_f64", 4usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmaq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmaq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmaq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmaq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_lane_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmaq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmaq_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_laneq_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmaq_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmaq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    f64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmaq_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmaq_n_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmas_lane_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, f32, crate::Unity::Burst::Intrinsics::v64, i32),
                f32,
                4usize,
            >("vfmas_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmas_lane_f32", 4usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vfmas_laneq_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, f32, crate::Unity::Burst::Intrinsics::v128, i32),
                f32,
                4usize,
            >("vfmas_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmas_laneq_f32", 4usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfms_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfms_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfms_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfms_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_lane_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfms_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vfms_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_laneq_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfms_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfms_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    f64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vfms_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfms_n_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsd_lane_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, f64, crate::Unity::Burst::Intrinsics::v64, i32),
                f64,
                4usize,
            >("vfmsd_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsd_lane_f64", 4usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsd_laneq_f64(
        a0: f64,
        a1: f64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, f64, crate::Unity::Burst::Intrinsics::v128, i32),
                f64,
                4usize,
            >("vfmsd_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsd_laneq_f64", 4usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmsq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmsq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmsq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmsq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_lane_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmsq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vfmsq_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_laneq_f64", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmsq_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmsq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    f64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vfmsq_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmsq_n_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vfmss_lane_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, f32, crate::Unity::Burst::Intrinsics::v64, i32),
                f32,
                4usize,
            >("vfmss_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmss_lane_f32", 4usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vfmss_laneq_f32(
        a0: f32,
        a1: f32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, f32, crate::Unity::Burst::Intrinsics::v128, i32),
                f32,
                4usize,
            >("vfmss_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vfmss_laneq_f32", 4usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_high_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                f32,
                2usize,
            >("vget_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                f64,
                2usize,
            >("vget_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i16,
                2usize,
            >("vget_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                2usize,
            >("vget_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i64,
                2usize,
            >("vget_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                i8,
                2usize,
            >("vget_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u16,
                2usize,
            >("vget_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u32,
                2usize,
            >("vget_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u64,
                2usize,
            >("vget_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                u8,
                2usize,
            >("vget_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_lane_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vget_low_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vget_low_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vget_low_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                f32,
                2usize,
            >("vgetq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                f64,
                2usize,
            >("vgetq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i16,
                2usize,
            >("vgetq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i32,
                2usize,
            >("vgetq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i64,
                2usize,
            >("vgetq_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                i8,
                2usize,
            >("vgetq_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u16,
                2usize,
            >("vgetq_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u32,
                2usize,
            >("vgetq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u64,
                2usize,
            >("vgetq_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vgetq_lane_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                u8,
                2usize,
            >("vgetq_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vgetq_lane_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhadd_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhadd_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhadd_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhadd_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhadd_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhadd_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhadd_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhadd_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhadd_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhadd_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhadd_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhadd_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhaddq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhaddq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhaddq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhaddq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhaddq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhaddq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhaddq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhaddq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhaddq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhaddq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhaddq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhaddq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhsub_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsub_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhsub_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsub_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhsub_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsub_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhsub_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsub_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhsub_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsub_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vhsub_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsub_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhsubq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsubq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhsubq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsubq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhsubq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsubq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhsubq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsubq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhsubq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsubq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vhsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vhsubq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vhsubq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vld1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vld1q_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vld1q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vld1q_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmax_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmax_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmax_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmaxnm_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxnm_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmaxnm_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxnm_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxnmq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxnmq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxnmq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxnmq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vmaxnmv_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxnmv_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f32,
                1usize,
            >("vmaxnmvq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxnmvq_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxnmvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vmaxnmvq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxnmvq_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmaxq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vmaxv_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxv_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i16,
                1usize,
            >("vmaxv_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxv_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i32,
                1usize,
            >("vmaxv_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxv_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i8,
                1usize,
            >("vmaxv_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxv_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u16,
                1usize,
            >("vmaxv_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxv_u16", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u32,
                1usize,
            >("vmaxv_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxv_u32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u8,
                1usize,
            >("vmaxv_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxv_u8", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f32,
                1usize,
            >("vmaxvq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vmaxvq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i16,
                1usize,
            >("vmaxvq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i32,
                1usize,
            >("vmaxvq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i8,
                1usize,
            >("vmaxvq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u16,
                1usize,
            >("vmaxvq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_u16", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u32,
                1usize,
            >("vmaxvq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_u32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmaxvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u8,
                1usize,
            >("vmaxvq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmaxvq_u8", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmin_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmin_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmin_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vminnm_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminnm_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vminnm_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminnm_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminnmq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminnmq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminnmq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminnmq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vminnmv_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminnmv_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f32,
                1usize,
            >("vminnmvq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminnmvq_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminnmvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vminnmvq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminnmvq_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vminq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vminv_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminv_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i16,
                1usize,
            >("vminv_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminv_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i32,
                1usize,
            >("vminv_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminv_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                i8,
                1usize,
            >("vminv_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminv_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u16,
                1usize,
            >("vminv_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminv_u16", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u32,
                1usize,
            >("vminv_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminv_u32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminv_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                u8,
                1usize,
            >("vminv_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminv_u8", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f32,
                1usize,
            >("vminvq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vminvq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i16,
                1usize,
            >("vminvq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i32,
                1usize,
            >("vminvq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i8,
                1usize,
            >("vminvq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u16,
                1usize,
            >("vminvq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_u16", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u32,
                1usize,
            >("vminvq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_u32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vminvq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u8,
                1usize,
            >("vminvq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vminvq_u8", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmla_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmla_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmla_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmla_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_high_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_high_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlal_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlal_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlal_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlal_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlaq_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlaq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlaq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlaq_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vmls_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmls_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmls_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmls_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_high_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_high_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsl_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsl_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsl_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_lane_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_lane_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_lane_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_laneq_f32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_laneq_u16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vmlsq_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_laneq_u32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    f32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_n_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    u32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmlsq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmlsq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmlsq_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i8),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u16),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u32),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmov_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u8),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmov_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmov_n_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_high_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_high_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_high_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_high_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_high_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_high_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovl_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmovn_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmovn_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmovn_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_high_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmovn_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmovn_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmovn_high_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_high_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmovn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmovn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmovn_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmovn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmovn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmovn_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovn_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_f32(
        a0: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_f64(
        a0: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s16(
        a0: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s32(
        a0: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s64(
        a0: i64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_s8(
        a0: i8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i8),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u16(
        a0: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u16),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u32(
        a0: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u32),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u64(
        a0: u64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmovq_n_u8(
        a0: u8,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u8),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmovq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmovq_n_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_lane_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_lane_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_lane_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_lane_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_laneq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_laneq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_laneq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmul_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_laneq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, f32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_n_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, f64),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_n_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i16),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, u16),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, u32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmul_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmul_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmul_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmuld_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                f64,
                3usize,
            >("vmuld_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmuld_lane_f64", 3usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmuld_laneq_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                f64,
                3usize,
            >("vmuld_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmuld_laneq_f64", 3usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_lane_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_lane_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_laneq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_high_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_laneq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, u16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, u32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_high_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_lane_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_lane_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_laneq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmull_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_laneq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, u16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, u32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmull_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmull_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmull_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_lane_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_lane_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_lane_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_lane_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_lane_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_laneq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_laneq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_laneq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_laneq_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_laneq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulq_laneq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_laneq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: f32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, f32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_n_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_n_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: f64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, f64),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_n_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_n_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, u16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, u32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmuls_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                f32,
                3usize,
            >("vmuls_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmuls_lane_f32", 3usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmuls_laneq_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                f32,
                3usize,
            >("vmuls_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmuls_laneq_f32", 3usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmulx_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulx_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vmulx_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulx_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmulx_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulx_lane_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmulx_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulx_lane_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmulx_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulx_laneq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulx_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vmulx_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulx_laneq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), f64, 2usize>("vmulxd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxd_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                f64,
                3usize,
            >("vmulxd_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxd_lane_f64", 3usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxd_laneq_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                f64,
                3usize,
            >("vmulxd_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxd_laneq_f64", 3usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulxq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vmulxq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_lane_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulxq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxq_lane_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_lane_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulxq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxq_lane_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_laneq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulxq_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxq_laneq_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxq_laneq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vmulxq_laneq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxq_laneq_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), f32, 2usize>("vmulxs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxs_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                f32,
                3usize,
            >("vmulxs_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxs_lane_f32", 3usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmulxs_laneq_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                f32,
                3usize,
            >("vmulxs_laneq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmulxs_laneq_f32", 3usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmvn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvn_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmvn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvn_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmvn_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvn_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmvn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvn_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmvn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvn_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvn_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vmvn_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvn_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmvnq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvnq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmvnq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvnq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmvnq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvnq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmvnq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvnq_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmvnq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvnq_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vmvnq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vmvnq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vmvnq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vneg_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vneg_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vneg_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vneg_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vneg_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vneg_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vneg_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vneg_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vneg_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vneg_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vneg_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vneg_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vneg_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), i64, 1usize>("vnegd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vnegd_s64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vnegq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vnegq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vnegq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vnegq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vnegq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vnegq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vnegq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vnegq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vnegq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vnegq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vnegq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vnegq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vnegq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorn_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorn_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorn_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vornq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vornq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vornq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorr_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vorr_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorr_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vorrq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vorrq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vorrq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadal_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadal_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadal_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadal_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadal_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadal_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadal_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadal_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadal_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadal_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadal_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadal_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadal_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpadalq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadalq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpadalq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadalq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpadalq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadalq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpadalq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadalq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpadalq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadalq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadalq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpadalq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadalq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadd_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadd_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadd_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadd_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadd_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadd_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadd_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadd_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadd_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadd_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadd_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadd_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpadd_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadd_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vpaddd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddd_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                i64,
                1usize,
            >("vpaddd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddd_s64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddd_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                u64,
                1usize,
            >("vpaddd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddd_u64", 1usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vpaddl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddl_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vpaddl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddl_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vpaddl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddl_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vpaddl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddl_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vpaddl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddl_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vpaddl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddl_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vpaddlq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddlq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vpaddlq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddlq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vpaddlq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddlq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vpaddlq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddlq_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vpaddlq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddlq_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vpaddlq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddlq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpaddq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpaddq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpadds_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vpadds_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpadds_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmax_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmax_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmax_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmax_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmax_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmax_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmax_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmax_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmax_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmax_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmax_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmax_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmax_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmax_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmax_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmaxnm_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxnm_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxnmq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxnmq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxnmq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxnmq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnmqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vpmaxnmqd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxnmqd_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxnms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vpmaxnms_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxnms_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpmaxq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vpmaxqd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxqd_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpmaxs_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vpmaxs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmaxs_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmin_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmin_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmin_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmin_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmin_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmin_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmin_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmin_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmin_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmin_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmin_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmin_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpmin_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpmin_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmin_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vpminnm_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminnm_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminnmq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminnmq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminnmq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminnmq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnmqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vpminnmqd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminnmqd_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpminnms_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vpminnms_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminnms_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vpminq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vpminqd_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                f64,
                1usize,
            >("vpminqd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpminqd_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vpmins_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                f32,
                1usize,
            >("vpmins_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vpmins_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqabs_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabs_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqabs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabs_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqabs_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabs_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabs_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqabs_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabs_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsb_s8(a0: i8) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8), i8, 1usize>("vqabsb_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabsb_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), i64, 1usize>("vqabsd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabsd_s64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16), i16, 1usize>("vqabsh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabsh_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqabsq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabsq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqabsq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabsq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqabsq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabsq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabsq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqabsq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabsq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqabss_s32(a0: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32), i32, 1usize>("vqabss_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqabss_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqadd_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadd_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8, i8), i8, 2usize>("vqaddb_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddb_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddb_u8(a0: u8, a1: u8) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u8, u8), u8, 2usize>("vqaddb_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddb_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vqaddd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddd_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vqaddd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16), i16, 2usize>("vqaddh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddh_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddh_u16(a0: u16, a1: u16) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, u16), u16, 2usize>("vqaddh_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddh_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqaddq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqaddq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqadds_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i32, 2usize>("vqadds_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadds_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqadds_u32(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u32), u32, 2usize>("vqadds_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqadds_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_high_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_high_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_high_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_high_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlal_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlal_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlal_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlal_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_lane_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                4usize,
            >("vqdmlalh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlalh_lane_s16", 4usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_laneq_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                i32,
                4usize,
            >("vqdmlalh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlalh_laneq_s16", 4usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlalh_s16(
        a0: i32,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i16, i16), i32, 3usize>("vqdmlalh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlalh_s16", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_lane_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                i64,
                4usize,
            >("vqdmlals_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlals_lane_s32", 4usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_laneq_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64, i32, crate::Unity::Burst::Intrinsics::v128, i32),
                i64,
                4usize,
            >("vqdmlals_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlals_laneq_s32", 4usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlals_s32(
        a0: i64,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32, i32), i64, 3usize>("vqdmlals_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlals_s32", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_high_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_high_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_high_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_high_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqdmlsl_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i16,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsl_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmlsl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsl_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_lane_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                4usize,
            >("vqdmlslh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlslh_lane_s16", 4usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_laneq_s16(
        a0: i32,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                i32,
                4usize,
            >("vqdmlslh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlslh_laneq_s16", 4usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlslh_s16(
        a0: i32,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i16, i16), i32, 3usize>("vqdmlslh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlslh_s16", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_lane_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                i64,
                4usize,
            >("vqdmlsls_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsls_lane_s32", 4usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_laneq_s32(
        a0: i64,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64, i32, crate::Unity::Burst::Intrinsics::v128, i32),
                i64,
                4usize,
            >("vqdmlsls_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsls_laneq_s32", 4usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmlsls_s32(
        a0: i64,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32, i32), i64, 3usize>("vqdmlsls_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmlsls_s32", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqdmulh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqdmulh_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqdmulh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqdmulh_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i16),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqdmulh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqdmulh_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqdmulh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqdmulh_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulh_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                i16,
                3usize,
            >("vqdmulhh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhh_lane_s16", 3usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                i16,
                3usize,
            >("vqdmulhh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhh_laneq_s16", 3usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16), i16, 2usize>("vqdmulhh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhh_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmulhq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmulhq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmulhq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmulhq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmulhq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmulhq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmulhq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmulhq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                3usize,
            >("vqdmulhs_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhs_lane_s32", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                i32,
                3usize,
            >("vqdmulhs_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhs_laneq_s32", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulhs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i32, 2usize>("vqdmulhs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulhs_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_high_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_high_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_high_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_high_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqdmull_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmull_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqdmull_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmull_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                3usize,
            >("vqdmullh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmullh_lane_s16", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                i32,
                3usize,
            >("vqdmullh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmullh_laneq_s16", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmullh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16), i32, 2usize>("vqdmullh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmullh_s16", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                i64,
                3usize,
            >("vqdmulls_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulls_lane_s32", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                i64,
                3usize,
            >("vqdmulls_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulls_laneq_s32", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqdmulls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i64, 2usize>("vqdmulls_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqdmulls_s32", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovn_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovn_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovn_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_high_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovn_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovn_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovn_high_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_high_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovn_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovn_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovn_u64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), i32, 1usize>("vqmovnd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovnd_s64", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnd_u64(a0: u64) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64), u32, 1usize>("vqmovnd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovnd_u64", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16), i8, 1usize>("vqmovnh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovnh_s16", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovnh_u16(a0: u16) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16), u8, 1usize>("vqmovnh_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovnh_u16", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovns_s32(a0: i32) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32), i16, 1usize>("vqmovns_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovns_s32", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovns_u32(a0: u32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32), u16, 1usize>("vqmovns_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovns_u32", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovun_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovun_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovun_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovun_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqmovun_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovun_high_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovun_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovun_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovun_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovun_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovun_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqmovun_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovun_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovund_s64(a0: i64) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), u32, 1usize>("vqmovund_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovund_s64", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovunh_s16(a0: i16) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16), u8, 1usize>("vqmovunh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovunh_s16", 1usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqmovuns_s32(a0: i32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32), u16, 1usize>("vqmovuns_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqmovuns_s32", 1usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqneg_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqneg_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqneg_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqneg_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqneg_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqneg_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqneg_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vqneg_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqneg_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegb_s8(a0: i8) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8), i8, 1usize>("vqnegb_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegb_s8", 1usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegd_s64(a0: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64), i64, 1usize>("vqnegd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegd_s64", 1usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegh_s16(a0: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16), i16, 1usize>("vqnegh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegh_s16", 1usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqnegq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegq_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqnegq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegq_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqnegq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegq_s64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vqnegq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqnegs_s32(a0: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32), i32, 1usize>("vqnegs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqnegs_s32", 1usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlah_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlah_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlah_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlah_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlah_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlah_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlah_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlah_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmlah_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlah_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlah_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmlah_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlah_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_lane_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                i16,
                4usize,
            >("vqrdmlahh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahh_lane_s16", 4usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_laneq_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                i16,
                4usize,
            >("vqrdmlahh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahh_laneq_s16", 4usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahh_s16(
        a0: i16,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16, i16), i16, 3usize>("vqrdmlahh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahh_s16", 3usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlahq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahq_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlahq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahq_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlahq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahq_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlahq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahq_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmlahq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmlahq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahs_lane_s32(
        a0: i32,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                4usize,
            >("vqrdmlahs_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahs_lane_s32", 4usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlahs_s32(
        a0: i32,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32, i32), i32, 3usize>("vqrdmlahs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlahs_s32", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlsh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlsh_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlsh_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlsh_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlsh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlsh_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                4usize,
            >("vqrdmlsh_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlsh_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmlsh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlsh_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlsh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmlsh_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlsh_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_lane_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, i16, crate::Unity::Burst::Intrinsics::v64, i32),
                i16,
                4usize,
            >("vqrdmlshh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshh_lane_s16", 4usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_laneq_s16(
        a0: i16,
        a1: i16,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, i16, crate::Unity::Burst::Intrinsics::v128, i32),
                i16,
                4usize,
            >("vqrdmlshh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshh_laneq_s16", 4usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshh_s16(
        a0: i16,
        a1: i16,
        a2: i16,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16, i16), i16, 3usize>("vqrdmlshh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshh_s16", 3usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlshq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshq_lane_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlshq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshq_lane_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlshq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshq_laneq_s16", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                4usize,
            >("vqrdmlshq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshq_laneq_s32", 4usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2, a3))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmlshq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmlshq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshs_lane_s32(
        a0: i32,
        a1: i32,
        a2: crate::Unity::Burst::Intrinsics::v64,
        a3: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, i32, crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                4usize,
            >("vqrdmlshs_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshs_lane_s32", 4usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2, a3)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmlshs_s32(
        a0: i32,
        a1: i32,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32, i32), i32, 3usize>("vqrdmlshs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmlshs_s32", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmulh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmulh_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmulh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqrdmulh_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i16),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrdmulh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrdmulh_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrdmulh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulh_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrdmulh_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulh_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                i16,
                3usize,
            >("vqrdmulhh_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhh_lane_s16", 3usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_laneq_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                i16,
                3usize,
            >("vqrdmulhh_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhh_laneq_s16", 3usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16), i16, 2usize>("vqrdmulhh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhh_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_lane_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmulhq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_lane_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmulhq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_laneq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmulhq_laneq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_laneq_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_laneq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrdmulhq_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_laneq_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i16,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i16),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrdmulhq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrdmulhq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrdmulhq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrdmulhq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                i32,
                3usize,
            >("vqrdmulhs_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhs_lane_s32", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_laneq_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                i32,
                3usize,
            >("vqrdmulhs_laneq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhs_laneq_s32", 3usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrdmulhs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i32, 2usize>("vqrdmulhs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrdmulhs_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshl_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8, i8), i8, 2usize>("vqrshlb_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlb_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u8, i8), u8, 2usize>("vqrshlb_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlb_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vqrshld_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshld_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i64), u64, 2usize>("vqrshld_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshld_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16), i16, 2usize>("vqrshlh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlh_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, i16), u16, 2usize>("vqrshlh_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlh_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqrshlq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshlq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i32, 2usize>("vqrshls_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshls_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshls_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, i32), u32, 2usize>("vqrshls_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshls_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrn_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrn_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrn_high_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_high_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrn_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_high_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrn_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_high_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrn_high_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_high_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrn_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrn_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrn_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrn_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrn_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrn_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrn_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), i32, 2usize>("vqrshrnd_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrnd_n_s64", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i32), u32, 2usize>("vqrshrnd_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrnd_n_u64", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i32), i8, 2usize>("vqrshrnh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrnh_n_s16", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrnh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, i32), u8, 2usize>("vqrshrnh_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrnh_n_u16", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i16, 2usize>("vqrshrns_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrns_n_s32", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrns_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, i32), u16, 2usize>("vqrshrns_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrns_n_u32", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrun_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrun_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrun_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrun_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqrshrun_high_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrun_high_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrun_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrun_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrun_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrun_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrun_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqrshrun_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrun_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrund_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), u32, 2usize>("vqrshrund_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrund_n_s64", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshrunh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i32), u8, 2usize>("vqrshrunh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshrunh_n_s16", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqrshruns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), u16, 2usize>("vqrshruns_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqrshruns_n_s32", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshl_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_n_s8(a0: i8, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8, i32), i8, 2usize>("vqshlb_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlb_n_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_n_u8(a0: u8, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u8, i32), u8, 2usize>("vqshlb_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlb_n_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8, i8), i8, 2usize>("vqshlb_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlb_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u8, i8), u8, 2usize>("vqshlb_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlb_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), i64, 2usize>("vqshld_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshld_n_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i32), u64, 2usize>("vqshld_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshld_n_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vqshld_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshld_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i64), u64, 2usize>("vqshld_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshld_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i32), i16, 2usize>("vqshlh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlh_n_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, i32), u16, 2usize>("vqshlh_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlh_n_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16), i16, 2usize>("vqshlh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlh_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, i16), u16, 2usize>("vqshlh_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlh_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshlq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i32, 2usize>("vqshls_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshls_n_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, i32), u32, 2usize>("vqshls_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshls_n_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i32, 2usize>("vqshls_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshls_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshls_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, i32), u32, 2usize>("vqshls_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshls_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshlu_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlu_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshlu_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlu_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshlu_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlu_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlu_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshlu_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlu_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlub_n_s8(a0: i8, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8, i32), u8, 2usize>("vqshlub_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlub_n_s8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlud_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), u64, 2usize>("vqshlud_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlud_n_s64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i32), u16, 2usize>("vqshluh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshluh_n_s16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshluq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshluq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshluq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshluq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshluq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshluq_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshluq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqshluq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshluq_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshlus_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), u32, 2usize>("vqshlus_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshlus_n_s32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrn_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrn_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrn_high_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_high_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrn_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_high_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrn_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_high_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrn_high_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_high_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrn_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrn_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrn_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrn_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrn_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrn_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrn_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), i32, 2usize>("vqshrnd_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrnd_n_s64", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i32), u32, 2usize>("vqshrnd_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrnd_n_u64", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i32), i8, 2usize>("vqshrnh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrnh_n_s16", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrnh_n_u16(a0: u16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, i32), u8, 2usize>("vqshrnh_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrnh_n_u16", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i16, 2usize>("vqshrns_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrns_n_s32", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrns_n_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, i32), u16, 2usize>("vqshrns_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrns_n_u32", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrun_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrun_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrun_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrun_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqshrun_high_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrun_high_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrun_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrun_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrun_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrun_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrun_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqshrun_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrun_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrund_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), u32, 2usize>("vqshrund_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrund_n_s64", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshrunh_n_s16(a0: i16, a1: i32) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i32), u8, 2usize>("vqshrunh_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshrunh_n_s16", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqshruns_n_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), u16, 2usize>("vqshruns_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqshruns_n_s32", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqsub_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsub_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubb_s8(a0: i8, a1: i8) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8, i8), i8, 2usize>("vqsubb_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubb_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubb_u8(a0: u8, a1: u8) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u8, u8), u8, 2usize>("vqsubb_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubb_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vqsubd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubd_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vqsubd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubh_s16(a0: i16, a1: i16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, i16), i16, 2usize>("vqsubh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubh_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubh_u16(a0: u16, a1: u16) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, u16), u16, 2usize>("vqsubh_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubh_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqsubq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubs_s32(a0: i32, a1: i32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, i32), i32, 2usize>("vqsubs_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubs_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqsubs_u32(a0: u32, a1: u32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, u32), u32, 2usize>("vqsubs_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqsubs_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqtbl1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbl1_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vqtbl1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbl1_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqtbl1q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbl1q_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbl1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vqtbl1q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbl1q_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqtbx1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbx1_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vqtbx1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbx1_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqtbx1q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbx1q_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vqtbx1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vqtbx1q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vqtbx1q_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vraddhn_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vraddhn_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vraddhn_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_high_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vraddhn_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_high_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vraddhn_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_high_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vraddhn_high_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_high_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vraddhn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vraddhn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vraddhn_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vraddhn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vraddhn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vraddhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vraddhn_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vraddhn_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbit_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrbit_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrbit_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbit_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrbit_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrbit_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbitq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrbitq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrbitq_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrbitq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrbitq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrbitq_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrecpe_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpe_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrecpe_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpe_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpe_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrecpe_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpe_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecped_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), f64, 1usize>("vrecped_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecped_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrecpeq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpeq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrecpeq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpeq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpeq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrecpeq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpeq_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpes_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), f32, 1usize>("vrecpes_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpes_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrecps_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrecps_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecps_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecps_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrecps_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecps_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), f64, 2usize>("vrecpsd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpsd_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrecpsq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpsq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrecpsq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpsq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpss_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), f32, 2usize>("vrecpss_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpss_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpxd_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), f64, 1usize>("vrecpxd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpxd_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrecpxs_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), f32, 1usize>("vrecpxs_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrecpxs_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev16_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev16_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev16_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev16_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev16q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev16q_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev16q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev16q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev16q_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev32_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev32_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev32_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev32_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev32q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32q_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev32q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32q_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev32q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32q_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev32q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev32q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev32q_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev64_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev64_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev64_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev64_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev64_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev64_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrev64_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev64q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64q_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev64q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64q_s16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev64q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64q_s32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev64q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64q_s8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev64q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64q_u16", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev64q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64q_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrev64q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrev64q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrev64q_u8", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrhadd_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhadd_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrhadd_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhadd_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrhadd_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhadd_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrhadd_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhadd_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrhadd_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhadd_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrhadd_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhadd_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrhaddq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhaddq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrhaddq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhaddq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrhaddq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhaddq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrhaddq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhaddq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrhaddq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhaddq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrhaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrhaddq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrhaddq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnd_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrnd_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrnd_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnd_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrnd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrnd_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnda_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrnda_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrnda_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrnda_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrnda_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrnda_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndaq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndaq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndaq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndaq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndaq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndaq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndi_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndi_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndi_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndi_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndi_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndi_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndiq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndiq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndiq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndiq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndiq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndiq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndm_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndm_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndm_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndm_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndm_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndm_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndmq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndmq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndmq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndmq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndmq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndmq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndn_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndn_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndn_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndn_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndn_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndn_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndnq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndnq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndnq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndnq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndnq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndnq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndns_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), f32, 1usize>("vrndns_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndns_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrndp_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndp_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndp_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndp_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndp_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndp_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndpq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndpq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndpq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndpq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndpq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndpq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndx_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndx_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndx_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndx_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrndx_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndx_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndxq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndxq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndxq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrndxq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrndxq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrndxq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshl_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vrshld_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshld_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i64), u64, 2usize>("vrshld_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshld_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshlq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshlq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshr_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshr_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshr_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), i64, 2usize>("vrshrd_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrd_n_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i32), u64, 2usize>("vrshrd_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrd_n_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrshrn_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrshrn_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrshrn_high_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_high_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrshrn_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_high_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrshrn_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_high_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrshrn_high_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_high_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshrn_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshrn_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshrn_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshrn_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshrn_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrshrn_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrn_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrshrq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrshrq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrshrq_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrsqrte_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrte_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrsqrte_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrte_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrte_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vrsqrte_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrte_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrted_f64(a0: f64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64), f64, 1usize>("vrsqrted_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrted_f64", 1usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrsqrteq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrteq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrsqrteq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrteq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrteq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vrsqrteq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrteq_u32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtes_f32(a0: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32), f32, 1usize>("vrsqrtes_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrtes_f32", 1usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrts_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsqrts_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrts_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrts_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsqrts_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrts_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsd_f64(a0: f64, a1: f64) -> quest_hook::libil2cpp::Result<f64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f64, f64), f64, 2usize>("vrsqrtsd_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrtsd_f64", 2usize
                )
            });
        let __cordl_ret: f64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrsqrtsq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrtsq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtsq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vrsqrtsq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrtsq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsqrtss_f32(a0: f32, a1: f32) -> quest_hook::libil2cpp::Result<f32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(f32, f32), f32, 2usize>("vrsqrtss_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsqrtss_f32", 2usize
                )
            });
        let __cordl_ret: f32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsra_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vrsra_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsra_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsrad_n_s64(
        a0: i64,
        a1: i64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64, i32), i64, 3usize>("vrsrad_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsrad_n_s64", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrsrad_n_u64(
        a0: u64,
        a1: u64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64, i32), u64, 3usize>("vrsrad_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsrad_n_u64", 3usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsraq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsraq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsraq_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsubhn_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsubhn_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsubhn_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_high_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsubhn_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_high_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsubhn_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_high_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vrsubhn_high_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_high_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsubhn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsubhn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsubhn_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsubhn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsubhn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vrsubhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vrsubhn_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vrsubhn_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s64(
        a0: i64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_s8(
        a0: i8,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i8, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u16(
        a0: u16,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u16, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u32(
        a0: u32,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u32, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u64(
        a0: u64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vset_lane_u8(
        a0: u8,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u8, crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vset_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vset_lane_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_f32(
        a0: f32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f32, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_f32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_f64(
        a0: f64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (f64, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_f64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s16(
        a0: i16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i16, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s32(
        a0: i32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i32, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s64(
        a0: i64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i64, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_s8(
        a0: i8,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (i8, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u16(
        a0: u16,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u16, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u32(
        a0: u32,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u32, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u64(
        a0: u64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u64, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsetq_lane_u8(
        a0: u8,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (u8, crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsetq_lane_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsetq_lane_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1cq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    u32,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsha1cq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha1cq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1h_u32(a0: u32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32), u32, 1usize>("vsha1h_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha1h_u32", 1usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1mq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    u32,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsha1mq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha1mq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1pq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: u32,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    u32,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsha1pq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha1pq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1su0q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsha1su0q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha1su0q_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha1su1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsha1su1q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha1su1q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256h2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsha256h2q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha256h2q_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256hq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsha256hq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha256hq_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256su0q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsha256su0q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha256su0q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsha256su1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsha256su1q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsha256su1q_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshl_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), i64, 2usize>("vshld_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshld_n_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i32), u64, 2usize>("vshld_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshld_n_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vshld_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshld_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vshld_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i64), u64, 2usize>("vshld_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshld_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_high_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_high_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_high_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_high_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_high_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_high_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_high_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_high_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_high_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshll_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshll_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshll_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshlq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshlq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshlq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshr_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshr_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshr_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrd_n_s64(a0: i64, a1: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i32), i64, 2usize>("vshrd_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrd_n_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vshrd_n_u64(a0: u64, a1: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i32), u64, 2usize>("vshrd_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrd_n_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vshrn_high_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_high_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vshrn_high_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_high_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vshrn_high_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_high_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vshrn_high_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_high_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vshrn_high_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_high_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_high_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vshrn_high_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_high_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshrn_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshrn_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshrn_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshrn_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshrn_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrn_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vshrn_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrn_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vshrq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128, i32),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vshrq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vshrq_n_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsli_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsli_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsli_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vslid_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64, i32), i64, 3usize>("vslid_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vslid_n_s64", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vslid_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64, i32), u64, 3usize>("vslid_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vslid_n_u64", 3usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsliq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsliq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsliq_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsqadd_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqadd_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsqadd_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqadd_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsqadd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqadd_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadd_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsqadd_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqadd_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddb_u8(a0: u8, a1: i8) -> quest_hook::libil2cpp::Result<u8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u8, i8), u8, 2usize>("vsqaddb_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqaddb_u8", 2usize
                )
            });
        let __cordl_ret: u8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddd_u64(a0: u64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, i64), u64, 2usize>("vsqaddd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqaddd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddh_u16(a0: u16, a1: i16) -> quest_hook::libil2cpp::Result<u16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u16, i16), u16, 2usize>("vsqaddh_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqaddh_u16", 2usize
                )
            });
        let __cordl_ret: u16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsqaddq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqaddq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsqaddq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqaddq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsqaddq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqaddq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqaddq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsqaddq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqaddq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqadds_u32(a0: u32, a1: i32) -> quest_hook::libil2cpp::Result<u32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u32, i32), u32, 2usize>("vsqadds_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqadds_u32", 2usize
                )
            });
        let __cordl_ret: u32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrt_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vsqrt_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqrt_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrt_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v64),
                crate::Unity::Burst::Intrinsics::v64,
                1usize,
            >("vsqrt_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqrt_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrtq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vsqrtq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqrtq_f32", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsqrtq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (crate::Unity::Burst::Intrinsics::v128),
                crate::Unity::Burst::Intrinsics::v128,
                1usize,
            >("vsqrtq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsqrtq_f64", 1usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsra_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsra_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsra_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsrad_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64, i32), i64, 3usize>("vsrad_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsrad_n_s64", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsrad_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64, i32), u64, 3usize>("vsrad_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsrad_n_u64", 3usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsraq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsraq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsraq_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsri_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vsri_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsri_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsrid_n_s64(a0: i64, a1: i64, a2: i32) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64, i32), i64, 3usize>("vsrid_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsrid_n_s64", 3usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsrid_n_u64(a0: u64, a1: u64, a2: i32) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64, i32), u64, 3usize>("vsrid_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsrid_n_u64", 3usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1, a2)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsriq_n_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: i32,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                    i32,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsriq_n_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsriq_n_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_f32", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_f64", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_s16", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_s32", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_s64", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_s8", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_u16", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_u32", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_u64", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1_u8", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_f32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_f32", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_f64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_f64", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_s16", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_s32", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_s64", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_s8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_s8", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u16(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_u16", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u32(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_u32", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u64(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_u64", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vst1q_u8(
        a0: quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<quest_hook::libil2cpp::Void> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    quest_hook::libil2cpp::Gc<quest_hook::libil2cpp::Il2CppObject>,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                quest_hook::libil2cpp::Void,
                2usize,
            >("vst1q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vst1q_u8", 2usize
                )
            });
        let __cordl_ret: quest_hook::libil2cpp::Void = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_f64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsub_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsub_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsub_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), i64, 2usize>("vsubd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubd_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsubd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vsubd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsubhn_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_high_s16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsubhn_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_high_s32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsubhn_high_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_high_s64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsubhn_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_high_u16", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsubhn_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_high_u32", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_high_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v128,
        a2: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                3usize,
            >("vsubhn_high_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_high_u64", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsubhn_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsubhn_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsubhn_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsubhn_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsubhn_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubhn_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vsubhn_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubhn_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_high_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_high_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubl_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubl_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubl_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_high_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_high_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_high_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_high_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_high_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_high_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_high_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_high_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_high_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_high_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_high_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_high_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_high_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vsubw_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vsubw_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vsubw_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbl1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtbl1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtbl1_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbl1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtbl1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtbl1_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbx1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vtbx1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtbx1_s8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtbx1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
        a2: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                3usize,
            >("vtbx1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtbx1_u8", 3usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1, a2))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn1_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn1_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn1_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn1_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn1_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn1q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn1q_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn2_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn2_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn2_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn2_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn2_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn2_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtrn2_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtrn2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtrn2q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtrn2q_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtst_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vtst_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtst_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstd_s64(a0: i64, a1: i64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, i64), u64, 2usize>("vtstd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstd_s64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vtstd_u64(a0: u64, a1: u64) -> quest_hook::libil2cpp::Result<u64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(u64, u64), u64, 2usize>("vtstd_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstd_u64", 2usize
                )
            });
        let __cordl_ret: u64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vtstq_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vtstq_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vtstq_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuqadd_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqadd_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuqadd_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqadd_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s64(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuqadd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqadd_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadd_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuqadd_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqadd_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddb_s8(a0: i8, a1: u8) -> quest_hook::libil2cpp::Result<i8> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i8, u8), i8, 2usize>("vuqaddb_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqaddb_s8", 2usize
                )
            });
        let __cordl_ret: i8 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddd_s64(a0: i64, a1: u64) -> quest_hook::libil2cpp::Result<i64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i64, u64), i64, 2usize>("vuqaddd_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqaddd_s64", 2usize
                )
            });
        let __cordl_ret: i64 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddh_s16(a0: i16, a1: u16) -> quest_hook::libil2cpp::Result<i16> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i16, u16), i16, 2usize>("vuqaddh_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqaddh_s16", 2usize
                )
            });
        let __cordl_ret: i16 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuqaddq_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqaddq_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuqaddq_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqaddq_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuqaddq_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqaddq_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqaddq_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuqaddq_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqaddq_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuqadds_s32(a0: i32, a1: u32) -> quest_hook::libil2cpp::Result<i32> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<(i32, u32), i32, 2usize>("vuqadds_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuqadds_s32", 2usize
                )
            });
        let __cordl_ret: i32 = unsafe { method.invoke_unchecked((), (a0, a1)) };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp1_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp1_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp1_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp1_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp1_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp1q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp1q_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp2_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp2_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp2_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp2_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp2_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp2_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vuzp2_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vuzp2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vuzp2q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vuzp2q_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip1_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip1_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip1_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip1_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip1_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip1_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip1_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip1q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip1q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip1q_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_f32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip2_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip2_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip2_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_s8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip2_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u16(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip2_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u32(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip2_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2_u8(
        a0: crate::Unity::Burst::Intrinsics::v64,
        a1: crate::Unity::Burst::Intrinsics::v64,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v64> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v64,
                    crate::Unity::Burst::Intrinsics::v64,
                ),
                crate::Unity::Burst::Intrinsics::v64,
                2usize,
            >("vzip2_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v64 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_f32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_f32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_f32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_f64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_f64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_f64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_s16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_s16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_s32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_s32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_s64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_s64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_s8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_s8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_s8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u16(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_u16")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_u16", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u32(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_u32")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_u32", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u64(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_u64")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_u64", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
    pub fn vzip2q_u8(
        a0: crate::Unity::Burst::Intrinsics::v128,
        a1: crate::Unity::Burst::Intrinsics::v128,
    ) -> quest_hook::libil2cpp::Result<crate::Unity::Burst::Intrinsics::v128> {
        static method: &'static quest_hook::libil2cpp::MethodInfo = <Self as quest_hook::libil2cpp::Type>::class()
            .find_static_method::<
                (
                    crate::Unity::Burst::Intrinsics::v128,
                    crate::Unity::Burst::Intrinsics::v128,
                ),
                crate::Unity::Burst::Intrinsics::v128,
                2usize,
            >("vzip2q_u8")
            .unwrap_or_else(|e| {
                panic!(
                    "no matching methods found for non-void {}.{}({}) Cause: {e:?}",
                    self, "vzip2q_u8", 2usize
                )
            });
        let __cordl_ret: crate::Unity::Burst::Intrinsics::v128 = unsafe {
            method.invoke_unchecked((), (a0, a1))
        };
        Ok(__cordl_ret.into())
    }
}
#[cfg(feature = "Unity+Burst+Intrinsics+Arm+Neon")]
impl quest_hook::libil2cpp::ObjectType for crate::Unity::Burst::Intrinsics::Arm_Neon {
    fn as_object(&self) -> &quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object(&self.__cordl_parent)
    }
    fn as_object_mut(&mut self) -> &mut quest_hook::libil2cpp::Il2CppObject {
        quest_hook::libil2cpp::ObjectType::as_object_mut(&mut self.__cordl_parent)
    }
}
